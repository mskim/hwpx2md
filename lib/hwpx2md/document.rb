require 'hwpx2md/containers'
require 'hwpx2md/elements'
require 'hwpx2md/image_extractor'
require 'hwpx2md/style_extractor'
require 'nokogiri'
require 'zip'
require 'fileutils'

module Hwpx2md

  class Document
    attr_reader :xml, :doc, :zip, :styles
    attr_reader :styles_hash, :footnotes_hash
    attr_accessor :footnote_number
    attr_accessor :text_with_footnote
    attr_reader :para_footnote_numbers, :para_footnotes
    attr_reader :txt_content
    attr_reader :zip, :image_extractor, :style_extractor

    def initialize(path_or_io, options = {})
      @replace = {}

      # if path-or_io is string && does not contain a null byte
      if (path_or_io.instance_of?(String) && !/\u0000/.match?(path_or_io))
        @zip = Zip::File.open(path_or_io)
      else
        @zip = Zip::File.open_buffer(path_or_io)
      end
      document = @zip.glob('Contents/section*.xml').first
      raise Errno::ENOENT if document.nil?
      @document_xml = document.get_input_stream.read
      
      # remove
      # </hp:t></hp:run><hp:run charPrIDRef="16"><hp:t>
      # </hp:t></hp:run><hp:run charPrIDRef="17"><hp:t>
      @document_xml.gsub!(/<\/hp\:t><\/hp\:run><hp\:run charPrIDRef=\"\d+\"><hp\:t>/, "")
      # @document_xml.gsub!(/</hp:t></hp:run><hp:run charPrIDRef=\"\d\d\"><hp:t>/, "")
      # binding.pry if @document_xml =~/\*\*<\/hp:t><hp:t\scharStyleIDRef=\"\d\d\">/
      @document_xml.gsub!(/<\/hp\:t><hp\:t\scharStyleIDRef=\"\d\d\">/, "")
      @document_xml.gsub!(/<\/hp\:t><hp\:t>\*\*/, "**")
      # path = File.expand_path("~/test/doc_test.xml")
      # File.write(path, @document_xml)
      @doc = Nokogiri::XML(@document_xml)
      # load_styles
      load_header
      init_image_extractor
      init_style_extractor
      yield(self) if block_given?
    ensure
      @zip.close if @zip
    end

    # Check if document contains images
    def has_images?
      @image_extractor&.has_images? || false
    end

    # Get count of images in document
    def image_count
      @image_extractor&.count || 0
    end

    # Extract images to specified directory
    #
    # @param output_dir [String] Directory to save images (default: "images" relative to document)
    # @param naming [Symbol] Naming convention (:descriptive, :sequential, :original)
    # @return [Hash] Map of bin_item_id to extracted file path
    def extract_images(output_dir = nil, naming: :descriptive)
      return {} unless has_images?

      output_dir ||= default_images_dir
      @image_extractor.extract_to(output_dir, naming: naming)
    end

    # Extract styles to specified directory as YAML files
    #
    # @param output_dir [String] Directory to save style files (default: "styles" relative to document)
    # @return [Array<String>] List of created files
    def extract_styles(output_dir = nil)
      return [] unless @style_extractor

      output_dir ||= default_styles_dir
      @style_extractor.save_to(output_dir)
    end

    # Get all styles as a hash
    #
    # @return [Hash] All document styles
    def styles_to_hash
      @style_extractor&.to_hash || {}
    end

    # Get all styles as YAML string
    #
    # @return [String] YAML representation of all styles
    def styles_to_yaml
      @style_extractor&.to_yaml || ""
    end

    # Get page properties (size, margins, etc.)
    #
    # @return [Hash] Page properties
    def page_properties
      @style_extractor&.document_properties || {}
    end

    # Get paragraph styles
    #
    # @return [Array<Hash>] List of paragraph styles
    def paragraph_styles
      @style_extractor&.paragraph_styles || []
    end

    # Get character styles
    #
    # @return [Array<Hash>] List of character styles
    def character_styles
      @style_extractor&.character_styles || []
    end

    # Get font definitions
    #
    # @return [Hash] Font definitions by language
    def font_definitions
      @style_extractor&.fonts || {}
    end

    # This stores the current global document properties, for now
    def document_properties
      {
        font_size: font_size,
        # hyperlinks: hyperlinks
      }
    end

    # With no associated block, Docx::Document.open is a synonym for Docx::Document.new. If the optional code block is given, it will be passed the opened +docx+ file as an argument and the Docx::Document oject will automatically be closed when the block terminates. The values of the block will be returned from Docx::Document.open.
    # call-seq:
    #   open(filepath) => file
    #   open(filepath) {|file| block } => obj
    def self.open(path, &block)
      new(path, &block)
    end

    def paragraphs
      @doc.xpath('//hs:sec/hp:p').map { |p_node| parse_paragraph_from p_node }
    end

    def bookmarks
      bkmrks_hsh = {}
      bkmrks_ary = @doc.xpath('//w:bookmarkStart').map { |b_node| parse_bookmark_from b_node }
      # auto-generated by office 2010
      bkmrks_ary.reject! { |b| b.name == '_GoBack' }
      bkmrks_ary.each { |b| bkmrks_hsh[b.name] = b }
      bkmrks_hsh
    end

    def to_xml
      Nokogiri::XML(@document_xml)
    end

    def tables
      @doc.xpath('//hs:sec//hp:tbl').map { |t_node| parse_table_from t_node }
    end

    # Some documents have this set, others don't.
    # Values are returned as half-points, so to get points, that's why it's divided by 2.
    def font_size
      return nil unless @styles

      size_tag = @styles.xpath('//w:docDefaults//w:rPrDefault//w:rPr//w:sz').first
      size_tag ? size_tag.attributes['val'].value.to_i / 2 : nil
    end

    # Hyperlink targets are extracted from the document.xml.rels file
    def hyperlinks
      hyperlink_relationships.each_with_object({}) do |rel, hash|
        hash[rel.attributes['Id'].value] = rel.attributes['Target'].value
      end
    end

    def hyperlink_relationships
      @rels.xpath("//xmlns:Relationship[contains(@Type,'hyperlink')]")
    end

    ##
    # *Deprecated*
    #
    # Iterates over paragraphs within document
    # call-seq:
    #   each_paragraph => Enumerator
    def each_paragraph
      paragraphs.each { |p| yield(p) }
    end

    # call-seq:
    #   to_s -> string
    def to_s
      paragraphs.map(&:to_s).join("\n")
    end

    def to_txt
      content = []
      image_paths = @image_extractor&.relative_paths || {}

      @doc.xpath('//hs:sec/*').each do |node|
        case node.name
        when 'p'
          # Check if paragraph contains a table
          table_node = node.at_xpath('.//hp:tbl')
          if table_node
            content << parse_table_from(table_node).to_markdown
          else
            # Check for images in paragraph
            pic_nodes = node.xpath('.//hp:pic')
            pic_nodes.each do |pic_node|
              image_node = Elements::Containers::ImageNode.new(pic_node, bin_items: @image_extractor&.bin_items || {})
              if image_node.valid? && image_paths[image_node.bin_item_id]
                content << image_node.to_markdown(image_paths[image_node.bin_item_id])
              end
            end
            # Add paragraph text
            para_text = parse_paragraph_from(node).to_txt(self)
            content << para_text unless para_text.strip.empty? && pic_nodes.any?
          end
        end
      end
      content.join("\n")
    end

    def to_markdown
      to_txt
    end

    def to_html
      content = to_txt
      require 'kramdown'
      html_content = Kramdown::Document.new(content).to_html
      <<~HTML
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <title>#{File.basename(@zip.name, '.*')}</title>
          <style>
            body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 40px auto; padding: 0 20px; }
            table { border-collapse: collapse; width: 100%; margin: 20px 0; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background-color: #f5f5f5; }
            tr:nth-child(even) { background-color: #f9f9f9; }
          </style>
        </head>
        <body>
          #{html_content}
        </body>
        </html>
      HTML
    end

    def save_as_markdown(path = nil, extract_images: true)
      # If no path provided, use the same name as input file but with .md extension
      unless path
        if @zip.name.is_a?(String)
          path = @zip.name.sub(/\.hwpx$/, '.md')
        else
          raise ArgumentError, "Path must be provided when input is not a file"
        end
      end

      # Extract images if present
      if extract_images && has_images?
        images_dir = File.join(File.dirname(path), "images")
        extract_images(images_dir)
      end

      # Convert and save content with UTF-8 encoding
      content = to_txt
      File.write(path, content, encoding: 'UTF-8')
      path
    end

    def save_as_html(path = nil, extract_images: true)
      # If no path provided, use the same name as input file but with .html extension
      unless path
        if @zip.name.is_a?(String)
          path = @zip.name.sub(/\.hwpx$/, '.html')
        else
          raise ArgumentError, "Path must be provided when input is not a file"
        end
      end

      # Extract images if present
      if extract_images && has_images?
        images_dir = File.join(File.dirname(path), "images")
        extract_images(images_dir)
      end

      # Convert and save content with UTF-8 encoding
      content = to_html
      File.write(path, content, encoding: 'UTF-8')
      path
    end

    def build_styles_hash
      # get style_name from style.xml
      hash = {}
      style_list =styles.xpath('//w:style')
      style_list.each do |style|        
        style_id = style.attribute('styleId').value
        style_name_node  = style.children.first
        style_name = style_name_node.attribute('val').value
        hash[style_id]  = style_name
      end
      @styles_hash = hash
    end

    def build_footnotes_hash
      @footnotes_hash = {}
      # first check if there are any footnotes
      footnotes_files = @zip.entries.map{|e| e.name}.select{|name| name=~/footnotes.xml/}.first
      if footnotes_files
        footnotes_xml = @zip.read('word/footnotes.xml')
        xml_node = Nokogiri::XML(footnotes_xml)
        footnote_nodes = xml_node.xpath('//w:footnotes//w:footnote')
        footnote_nodes.each do |footnote|
          footnote_id = footnote.attribute('id').value
          footnote_text_node = footnote.at_xpath('.//w:t')
          footnote_text = footnote_text_node.text
          @footnotes_hash[footnote_id] = footnote_text
        end
      end
      @footnotes_hash
    end

    # Save document to provided path
    # call-seq:
    #   save(filepath) => void
    def save(path)
      update
      Zip::OutputStream.open(path) do |out|
        zip.each do |entry|
          next unless entry.file?

          out.put_next_entry(entry.name)

          if @replace[entry.name]
            out.write(@replace[entry.name])
          else
            out.write(zip.read(entry.name))
          end
        end
      end
      zip.close
    end

    # Output entire document as a StringIO object
    def stream
      update
      stream = Zip::OutputStream.write_buffer do |out|
        zip.each do |entry|
          next unless entry.file?

          out.put_next_entry(entry.name)

          if @replace[entry.name]
            out.write(@replace[entry.name])
          else
            out.write(zip.read(entry.name))
          end
        end
      end

      stream.rewind
      stream
    end

    def replace_entry(entry_path, file_contents)
      @replace[entry_path] = file_contents
    end

    private

    def load_styles
      @styles_xml = @zip.read('word/styles.xml')
      @styles = Nokogiri::XML(@styles_xml)
      load_rels
    rescue Errno::ENOENT => e
      warn e.message
      nil
    end



    def load_rels
      rels_entry = @zip.glob('word/_rels/document*.xml.rels').first
      raise Errno::ENOENT unless rels_entry

      @rels_xml = rels_entry.get_input_stream.read
      @rels = Nokogiri::XML(@rels_xml)
    end

    #--
    # TODO: Flesh this out to be compatible with other files
    # TODO: Method to set flag on files that have been edited, probably by inserting something at the
    # end of methods that make edits?
    #++
    def update
      replace_entry 'word/document.xml', doc.serialize(save_with: 0)
    end

    # generate Elements::Containers::Paragraph from paragraph XML node
    def parse_paragraph_from(p_node)
      Elements::Containers::Paragraph.new(p_node, document_properties)
    end

    # generate Elements::Bookmark from bookmark XML node
    def parse_bookmark_from(b_node)
      Elements::Bookmark.new(b_node)
    end

    def parse_table_from(t_node)
      Elements::Containers::Table.new(t_node)
    end

    # Load header.xml for binary item references
    def load_header
      header_entry = @zip.glob('Contents/header.xml').first
      return unless header_entry

      @header_xml = header_entry.get_input_stream.read
      @header_doc = Nokogiri::XML(@header_xml)
    rescue StandardError
      @header_doc = nil
    end

    # Initialize image extractor
    def init_image_extractor
      @image_extractor = ImageExtractor.new(@zip, @doc, @header_doc)
    rescue StandardError
      @image_extractor = nil
    end

    # Default images directory based on document path
    def default_images_dir
      if @zip.name.is_a?(String)
        File.join(File.dirname(@zip.name), "images")
      else
        "images"
      end
    end

    # Initialize style extractor
    def init_style_extractor
      @style_extractor = StyleExtractor.new(@header_doc, @doc)
    rescue StandardError
      @style_extractor = nil
    end

    # Default styles directory based on document path
    def default_styles_dir
      if @zip.name.is_a?(String)
        File.join(File.dirname(@zip.name), "styles")
      else
        "styles"
      end
    end
  end
end
